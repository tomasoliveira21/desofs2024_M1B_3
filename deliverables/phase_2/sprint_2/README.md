# Phase 2 - Sprint 2

## Objective

In this sprint we were expected to develop the rest of the application, following the best practices possible and implementing/enhancing the pipeline and/or tests.

## Supabase

Supabase provided us with the Database, Authentication and Storage systems needed to make our backend application. Our database is hosted on AWS, in Europe and is fully accessible as any other database would be, but higly discouraged since Supabase provides all the means to safely manage the database without risk of data corruption.

![Supabase Architecture](img/supabase-architecture.svg)

Supabase uses Kong as the webserver for the multiple paths and, specifically for the database, it implements a REST ([PostgREST](https://postgrest.org/en/v12/)) interface on top of Postgres that allows multiple operations such as Authentication and Authorization.

### Database

Under the hood, it uses [Row Level Security](https://supabase.com/docs/guides/database/postgres/row-level-security) rules, following the official [Row Security Policies](https://www.postgresql.org/docs/current/ddl-rowsecurity.html) Postgres Implementation and, for us, this means that we can implement our RBAC in the Backend and at the Database level. When a RLS rule is created, prior to an UPDATE, INSERT, DELETE or any operation these policies are validated against the user that is trying to perform the action; if the rule fails than the action is not carried on (for instance `default` users cannot delete tweets so they cannot perform a `DELETE FROM socialnet."Tweets"` operation).

Supabase also allows custom [Custom Claims & Role-based Access Control (RBAC)](https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac?queryGroups=language&language=plpgsql) by implementing a set of rules and Postgres policies and these are reflected in the generated [JWT token](https://supabase.com/docs/guides/auth/jwts), so we can control operations in the backend by validating this token.

We ended up creating the following tables on the `socialnet` schema in our database:

![Database Schema](img/database_schema.png)

In this database schema there are references to the table `auth.user.id`, which is a managed table by Supabase and has information regarding the users that are registered onto the project, such as if they have OTP enabled, MFA, if they are verified, their Unique ID, etc. We reference that table for our operations but cannot change the table itself.

#### Users

To fetch user information we ended up creating a [View](https://www.postgresql.org/docs/current/sql-createview.html), which queries information from multiple tables and allows users to query this view as if it was a table. From a security point-of-view this is better than managing a new table because these queries are ran by Postgres and do not accept user inputs, so information cannot be changed while querying a view.

```sql
CREATE OR REPLACE VIEW
  socialnet."users" AS
SELECT
  u.id,
  u.email,
  ur.role,
  LOWER(
    regexp_replace(
      TRIM(SPLIT_PART(u.email, '@', 1)),
      '[^a-zA-Z0-9]',
      '_',
      'g'
    )
  ) AS username
FROM
  auth.users AS u
  INNER JOIN socialnet.user_roles AS ur ON u.id = ur.user_id;
```

![Users View](img/users_view.png)

This view feeds our backend with information regarding the users that we can then return to the frontend and references the original `auth.users` table without changing any information.

#### Trends

For the Trends functionality we have created another view that is dynamic, showing us the top-10 Hashtags from the last 24 hours.

```sql
DROP VIEW IF EXISTS socialnet.trends;
CREATE VIEW socialnet.trends AS
SELECT
    name,
    COUNT(*) AS count,
    ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC) AS position
FROM     socialnet."Hashtags"
WHERE    created_at >= Now() - interval '1 DAYS'
group BY name
ORDER BY count DESC limit 10;
```

![Trends View](img/trends_view.png)

#### Tweets and Hashtags

##### Tweets

```sql
create table
  socialnet."Tweets" (
    id bigint generated by default,
    created_at timestamp with time zone not null default now(),
    content text not null,
    uuid uuid not null default gen_random_uuid () as identity,
    user_uuid uuid not null default auth.uid (),
    constraint Tweets_pkey primary key (id),
    constraint Tweets_uuid_key unique (uuid),
    constraint Tweets_user_uuid_fkey foreign key (user_uuid) references auth.users (id) on update cascade on delete cascade
  ) tablespace pg_default;
```

Our Tweets are **not** identified by an incremental `id` but by an [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier) that is generated whenever a Tweet is posted and provides an extra security against SQL injection attacks, since it would be near impossible to randomly guess an UUID since these values depend on the Operating System that is generating them, the time, the content, etc.

To these table we applied the following RLS policies:

```sql
create policy "Allow tweet post" on socialnet."Tweets" for insert to authenticated
with
  check (
    (
      select
        auth.uid ()
    ) = user_id
  );
create policy "Allow authorized delete" on socialnet."Tweets" for delete using (
  (
    SELECT
      socialnet.authorize ('tweet.delete')
  )
);
```

Any authenticated (default PostgREST role for authenticated users and, in our case, corresponds to the `default` user)  user can post a Tweet since it is a basic functionallity of the Socialnet Application, but only users that have the `tweet.delete` permission can perform a DELETE operation (more information on [RBAC](#rbac)).

##### Hashtags

The hashtags are identified by an incremental ID because they are associated with a tweet and there is the Foreign Key constraint that prevents a single delete of an Hashtag while the referenced Tweet still exists and they simply contain a name.

```sql
create table
  socialnet."Hashtags" (
    id bigint generated by default as identity,
    created_at timestamp with time zone not null default now(),
    name text not null,
    tweet_uuid uuid not null,
    constraint Hashtags_pkey primary key (id),
    constraint Hashtags_tweet_uuid_key unique (tweet_uuid),
    constraint Hashtags_tweet_uuid_fkey foreign key (tweet_uuid) references socialnet."Tweets" (uuid) on update cascade on delete cascade
  ) tablespace pg_default;
```

We created the following RLS policies:

```sql
create policy "Allow authorized delete" on socialnet."Hashtags" for delete using (
  (
    SELECT
      socialnet.authorize ('hashtag.delete')
  )
);
```

Following the Tweets logic, only users with the `hashtag.delete` permission can perform a `DELETE` operation on this table.

#### Row Level Security Policies

#### RBAC

### Storage

Supabase provides us with an [S3-compatible object storage service](https://supabase.com/docs/guides/getting-started/architecture#storage-api-large-file-storage) that we use to host our profile pictures and tweet images. Database policies also apply here since each object has it's own corresponding row in the `auth.storage` table and, by using a REST API with authorization, Supabase is capable of validating if whoever is requesting an object is allowed to perform that request, which introduces another extra level of security for data-at-rest (by also using RLS policies).

We created the following RLS policies for the storage table:

```sql
CREATE POLICY "Users can Upload Profile Pictures 1mkux3k_0" ON storage.objects FOR
SELECT TO authenticated USING (bucket_id = 'socialnet');
CREATE POLICY "Users can Upload Profile Pictures 1mkux3k_1" ON storage.objects FOR
INSERT TO authenticated WITH CHECK (bucket_id = 'socialnet');
```

## Backend

We have fully developed our backend using Python 3.11.

We used Pydantic for data and model validation, FastAPI to serve our endpoints and the Supabase Python Client to access our Supabase Project.
